import numpy as np
from numpy.typing import NDArray
import time
from lattice.core import clip


def clip_std(B: NDArray, x: NDArray) -> NDArray:
    """
    Finds the point in the lattice generated by `B` that is closest to `x`.
    Follows the Algorithm 5 in https://doi.org/10.1109/TIT.2011.2143830.
    Thanks to https://github.com/maflcko/SphereDecoding/blob/master/decode5.m.

    :param B: the generator matrix of the lattice
    :type B: NDArray
    :param x: the vector in the space
    :type x: NDArray
    :return: the closest lattice point in `B` that is closest to `x`
    :rtype: NDArray
    """

    def sign(val: int | float) -> int:
        return 1 if val > 0 else -1

    n = B.shape[0]
    assert x.shape == (n,) and B.shape == (n, n)

    u = np.zeros(n, dtype=np.int32)
    u_closest = np.zeros(n, dtype=np.int32)
    step = np.zeros(n, dtype=np.int32)
    d = np.full(n, fill_value=(n - 1), dtype=np.int32)

    p = np.zeros(n)
    dist = np.zeros(n + 1)
    F = np.zeros((n, n))

    rho_n = float("inf")
    k = n
    F[-1, :] = x

    loop_down = True

    while True:
        while loop_down:
            if k != 0:
                k -= 1
                for j in range(d[k], k, -1):
                    F[j - 1, k] = F[j, k] - u[j] * B[j, k]
                p[k] = F[k, k] / B[k, k]
                u[k] = round(p[k])
                gamma = (p[k] - u[k]) * B[k, k]
                step[k] = sign(gamma)
                dist[k] = dist[k + 1] + gamma**2
            else:
                u_closest[:] = u
                rho_n = dist[0]
            loop_down = dist[k] < rho_n

        m = k
        while not loop_down:
            if k == n - 1:
                return u_closest
            else:
                k += 1
                u[k] = u[k] + step[k]
                step[k] = -step[k] - sign(step[k])
                gamma = (p[k] - u[k]) * B[k, k]
                dist[k] = dist[k + 1] + gamma**2
            loop_down = dist[k] < rho_n

        d[m:k] = k
        for a in range(m - 1, 0, -1):
            if d[a] < k:
                d[a] = k
            else:
                break


if __name__ == "__main__":
    import time

    def random_tril(i: int) -> NDArray:
        A = np.random.standard_normal((10, 10))
        return np.linalg.cholesky(A @ A.T)

    print("Testing correctness: ")
    for _ in range(10):
        A = random_tril(10)
        v = np.random.standard_normal(10)
        B_std = clip_std(A, v)
        B_out = clip(A, v)
        np.testing.assert_allclose(B_out, B_std)
    print("Correctness passed!")
    print(f"Testing Speed:")
    ITER = 5000
    start = time.time()
    for _ in range(ITER):
        A = random_tril(10)
        v = np.random.standard_normal(10)
        clip_std(A, v)
    cost = time.time() - start
    print(f"Python: {ITER} iter / {cost} sec = {ITER/cost} iteration per second in average.")
    ITER = 100000
    start = time.time()
    for _ in range(ITER):
        A = random_tril(10)
        v = np.random.standard_normal(10)
        clip(A, v)
    cost = time.time() - start
    print(f"Python: {ITER} iter / {cost} sec = {ITER/cost} iteration per second in average.")
